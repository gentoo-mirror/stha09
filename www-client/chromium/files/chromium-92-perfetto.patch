From a7fdb40465618bf0c5a10a2f753538d7acfbfa1a Mon Sep 17 00:00:00 2001
From: Alexander Timin <altimin@google.com>
Date: Mon, 19 Apr 2021 15:22:07 +0000
Subject: [PATCH] Switch protozero metadata variables back to static functions

Use inline static functions as they are guaranteed to work (the previous
approach of using constexpr const& didn't actually work with gcc.

Add a comment explaning the rationale to the generated bindings to
prevent suprises.

R=skyostil@google.com
CC=eseckler@google.com,primiano@google.com

Bug: b/184558843
Change-Id: I50c7d069d8aae785ee38dee7f2991c532819aa9a
---
 include/perfetto/protozero/proto_utils.h      | 15 ++++++++++
 .../tracing/internal/write_track_event_args.h |  3 +-
 include/perfetto/tracing/traced_proto.h       |  7 +++--
 .../protoc_plugin/protozero_plugin.cc         | 29 ++++++++++++-------
 4 files changed, 40 insertions(+), 14 deletions(-)

diff --git a/third_party/perfetto/include/perfetto/protozero/proto_utils.h b/third_party/perfetto/include/perfetto/protozero/proto_utils.h
index bb2e5cee1..841042b17 100644
--- a/third_party/perfetto/include/perfetto/protozero/proto_utils.h
+++ b/third_party/perfetto/include/perfetto/protozero/proto_utils.h
@@ -276,6 +276,21 @@ struct FieldMetadata : public FieldMetadataBase {
   using message_type = MessageType;
 };
 
+namespace internal {
+
+// Ideally we would create variables of FieldMetadata<...> type directly,
+// but before C++17's support for constexpr inline variables arrive, we have to
+// actually use pointers to inline functions instead to avoid having to define
+// symbols in *.pbzero.cc files.
+//
+// Note: protozero bindings will generate Message::kFieldName variable and which
+// can then be passed to TRACE_EVENT macro for inline writing of typed messages.
+// The fact that the former can be passed to the latter is a part of the stable
+// API, while the particular type is not and users should not rely on it.
+template <typename T>
+using FieldMetadataHelper = T (*)(void);
+
+}  // namespace internal
 }  // namespace proto_utils
 }  // namespace protozero
 
diff --git a/include/perfetto/tracing/internal/write_track_event_args.h b/include/perfetto/tracing/internal/write_track_event_args.h
index 82631107a..9a68ab525 100644
--- a/third_party/perfetto/include/perfetto/tracing/internal/write_track_event_args.h
+++ b/third_party/perfetto/include/perfetto/tracing/internal/write_track_event_args.h
@@ -100,7 +100,8 @@ template <typename FieldMetadataType,
                               FieldMetadataType>::value>>
 PERFETTO_ALWAYS_INLINE void WriteTrackEventArgs(
     EventContext event_ctx,
-    const FieldMetadataType& field_name,
+    protozero::proto_utils::internal::FieldMetadataHelper<FieldMetadataType>
+        field_name,
     ArgValue&& arg_value,
     Args&&... args) {
   static_assert(
diff --git a/third_party/perfetto/include/perfetto/tracing/traced_proto.h b/third_party/perfetto/include/perfetto/tracing/traced_proto.h
index d88dbc1a3..88ee99e13 100644
--- a/third_party/perfetto/include/perfetto/tracing/traced_proto.h
+++ b/third_party/perfetto/include/perfetto/tracing/traced_proto.h
@@ -166,9 +166,10 @@ struct TypedProtoWriter {
 }  // namespace internal
 
 template <typename MessageType, typename FieldMetadataType, typename ValueType>
-void WriteIntoTracedProto(TracedProto<MessageType> message,
-                          const FieldMetadataType&,
-                          ValueType&& value) {
+void WriteIntoTracedProto(
+    TracedProto<MessageType> message,
+    protozero::proto_utils::internal::FieldMetadataHelper<FieldMetadataType>,
+    ValueType&& value) {
   static_assert(
       std::is_base_of<protozero::proto_utils::FieldMetadataBase,
                       FieldMetadataType>::value,
diff --git a/third_party/perfetto/src/protozero/protoc_plugin/protozero_plugin.cc b/third_party/perfetto/src/protozero/protoc_plugin/protozero_plugin.cc
index e2d3192ad..c3dc58b3c 100644
--- a/third_party/perfetto/src/protozero/protoc_plugin/protozero_plugin.cc
+++ b/third_party/perfetto/src/protozero/protoc_plugin/protozero_plugin.cc
@@ -831,16 +831,25 @@ class GeneratorJob {
 
   void GenerateFieldMetadata(const std::string& message_cpp_type,
                              const FieldDescriptor* field) {
-    const char* code_stub =
-        "using $field_metadata_type$ =\n"
-        "  ::protozero::proto_utils::FieldMetadata<\n"
-        "    $field_id$,\n"
-        "    ::protozero::proto_utils::RepetitionType::$repetition_type$,\n"
-        "    ::protozero::proto_utils::ProtoSchemaType::$proto_field_type$,\n"
-        "    $cpp_type$,\n"
-        "    $message_cpp_type$>;\n"
-        "static constexpr const $field_metadata_type$& $field_metadata_var$ = "
-        "{};\n";
+    const char* code_stub = R"(
+using $field_metadata_type$ =
+  ::protozero::proto_utils::FieldMetadata<
+    $field_id$,
+    ::protozero::proto_utils::RepetitionType::$repetition_type$,
+    ::protozero::proto_utils::ProtoSchemaType::$proto_field_type$,
+    $cpp_type$,
+    $message_cpp_type$>;
+
+// Ceci n'est pas une pipe.
+// This is actually a variable of FieldMetadataHelper<FieldMetadata<...>>
+// type (and users are expected to use it as such, hence kCamelCase name).
+// It is declared as a function to keep protozero bindings header-only as
+// inline constexpr variables are not available until C++17 (while inline
+// functions are).
+// TODO(altimin): Use inline variable instead after adopting C++17.  
+static constexpr $field_metadata_type$ $field_metadata_var$() { return {}; }
+)";
+
     stub_h_->Print(code_stub, "field_id", std::to_string(field->number()),
                    "repetition_type", FieldToRepetitionType(field),
                    "proto_field_type", FieldToProtoSchemaType(field),
