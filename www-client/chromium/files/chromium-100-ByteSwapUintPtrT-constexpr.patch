From 1ea2079fec7098cd0fdfabce259d65a09197532d Mon Sep 17 00:00:00 2001
From: Stephan Hartmann <stha09@googlemail.com>
Date: Thu, 27 Jan 2022 14:36:21 +0000
Subject: [PATCH] GCC: add constexpr to base::ByteSwapUintPtrT and
 base::ByteSwap

base::internal::EncodedPartitionFreelistEntryPtr::Transform() is
constexpr. This requires base::ByteSwapUintPtrT() and
base::ByteSwap() to be constexpr too.
---
 base/sys_byteorder.h | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/base/sys_byteorder.h b/base/sys_byteorder.h
index 4de2b5f..d86cc36 100644
--- a/base/sys_byteorder.h
+++ b/base/sys_byteorder.h
@@ -22,7 +22,7 @@
 namespace base {
 
 // Returns a value with all bytes in |x| swapped, i.e. reverses the endianness.
-inline uint16_t ByteSwap(uint16_t x) {
+constexpr uint16_t ByteSwap(uint16_t x) {
 #if defined(COMPILER_MSVC) && !defined(__clang__)
   return _byteswap_ushort(x);
 #else
@@ -30,7 +30,7 @@ inline uint16_t ByteSwap(uint16_t x) {
 #endif
 }
 
-inline uint32_t ByteSwap(uint32_t x) {
+constexpr uint32_t ByteSwap(uint32_t x) {
 #if defined(COMPILER_MSVC) && !defined(__clang__)
   return _byteswap_ulong(x);
 #else
@@ -38,7 +38,7 @@ inline uint32_t ByteSwap(uint32_t x) {
 #endif
 }
 
-inline uint64_t ByteSwap(uint64_t x) {
+constexpr uint64_t ByteSwap(uint64_t x) {
   // Per build/build_config.h, clang masquerades as MSVC on Windows. If we are
   // actually using clang, we can rely on the builtin.
   //
@@ -53,7 +53,7 @@ inline uint64_t ByteSwap(uint64_t x) {
 #endif
 }
 
-inline uintptr_t ByteSwapUintPtrT(uintptr_t x) {
+constexpr uintptr_t ByteSwapUintPtrT(uintptr_t x) {
   // We do it this way because some build configurations are ILP32 even when
   // defined(ARCH_CPU_64_BITS). Unfortunately, we can't use sizeof in #ifs. But,
   // because these conditionals are constexprs, the irrelevant branches will
-- 
2.34.1

